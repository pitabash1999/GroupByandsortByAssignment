package com.assignment1.service;



import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import com.assignment1.dto.GroupedRecords;
import com.assignment1.dto.SaveRecordRequest;
import com.assignment1.dto.SavedResponseDto;
import com.assignment1.exceptions.EmptyDataSetException;
import com.assignment1.model.Dataset;
import com.assignment1.model.Record;
import com.assignment1.model.ResponseMessage;
import com.assignment1.repository.DatasetRepository;
import com.assignment1.repository.RecordRepository;
import com.assignment1.service.interfaces.GroupbySortByMethods;



@Service
public class GroupbySortByMethodsImpl implements GroupbySortByMethods {
	
	@Autowired
	private DatasetRepository datasetRepository;
	@Autowired
	private RecordRepository recordRepository;
	
	
    @Override
    public SavedResponseDto saveRecord(String dataset, SaveRecordRequest request)throws NoResourceFoundException {
    	
    	if("null".equals(dataset) || "null".equals(request)) {
    		throw new IllegalArgumentException("NUll values are not accepted");
    	}
    	
    	if(dataset.isEmpty()) {
    		throw new EmptyDataSetException("Dataset can not be a empty");
    	}
    	
    	try {
    		
    		Optional<Dataset> existingDataset=datasetRepository.findBydatasetName(dataset);
        	
        	if(existingDataset.isPresent()) {
        		Record record=new Record();
        		record.setName(request.getName());
        		record.setAge(request.getAge());
        		record.setDepartment(request.getDepartment());
        		record.setDataset(existingDataset.get());
        		Record savedRecord=recordRepository.save(record);
        		
        		return responseDto(savedRecord.getId(), dataset, ResponseMessage.SUCCESS.getMessage());
        	}else {
        		Dataset newDataset=new Dataset();
        		newDataset.setDatasetName(dataset);
        		Dataset savedDataset=datasetRepository.save(newDataset);
        		Record record=new Record();
        		record.setName(request.getName());
        		record.setAge(request.getAge());
        		record.setDepartment(request.getDepartment());;
        		record.setDataset(savedDataset);
        		Record savedRecord=recordRepository.save(record);
        		
        		return responseDto(savedRecord.getId(), dataset, ResponseMessage.SUCCESS.getMessage());
        	}
			
		} catch (Exception e) {
			throw new InternalError();
		}
    	
    	
    }
    
    
    
    
    private SavedResponseDto responseDto(Long recordId,String datasetName,String message) {
    	
    	return SavedResponseDto.builder()
    			.message(message)
    			.dataset(datasetName)
    			.recordId(recordId)
    			.build();
    	
    }


	@Override
	public Map<String, List<GroupedRecords>> getGroupedRecords(String datasetName, String groupByParam) {
		
		Map<String,List<GroupedRecords>> result=new HashMap<>();
		if(groupByParam.equalsIgnoreCase("age")) {
			
			List<Integer> ages= datasetRepository.findByAgeDatasetName(datasetName);
			
			
			for(Integer age:ages) {
				
				List<Record> records=recordRepository.findByAge(age);
				List<GroupedRecords> groupedRecords=records.stream()
						.map(record-> convertToGroupedRecordDto(record))
						.toList();
				result.put(String.valueOf(age), groupedRecords);
			}
			
			
			
			
		}else if(groupByParam.equalsIgnoreCase("department")) {
			
			List<String> departments= datasetRepository.findByDepartmentsDatasetName(datasetName);
			
			
			for(String department:departments) {
				
				List<Record> records=recordRepository.findByDepartment(department);
				List<GroupedRecords> groupedRecords=records.stream()
						.map(record-> convertToGroupedRecordDto(record))
						.toList();
				result.put(department, groupedRecords);
			}
			
			
			
			
		}else if(groupByParam.equalsIgnoreCase("name")) {
			
			List<String> names= datasetRepository.findBynamesDatasetName(datasetName);
			
			
			for(String name:names) {
				
				List<Record> records=recordRepository.findByName(name);
				List<GroupedRecords> groupedRecords=records.stream()
						.map(record-> convertToGroupedRecordDto(record))
						.toList();
				result.put(name, groupedRecords);
			}
			
			
			
			
		}
		
		return result;
	}
	
	private GroupedRecords convertToGroupedRecordDto(Record record) {
		
		return GroupedRecords.builder()
				.id(record.getId())
				.name(record.getName())
				.age(record.getAge())
				.department(record.getDepartment())
				.build();
	}
}
